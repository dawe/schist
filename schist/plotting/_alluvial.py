from typing import Optional, Tuple, Sequence, Type, Union, Literal
import numpy as np

import matplotlib.pyplot as plt
#from matplotlib import rcParams, ticker
#from matplotlib.axes import Axes
#from matplotlib.colors import is_color_like
#from matplotlib.figure import Figure
from matplotlib.patches import Polygon
from anndata import AnnData
import pandas as pd
#from ._utils import get_ncolors


def alluvial(
    adata: AnnData,
    level_start: int = 1,
    level_end: int = None,
    key: str = 'nsbm',
    gap: float = 0.05,
    legend_fontsize: Union[int, float, Literal['xx-small', 'x-small', 'small', 
                           'medium', 'large', 'x-large', 'xx-large']] = None,
    legend_fontweight: Union[int, Literal['light', 'normal', 'medium', 
                             'semibold', 'bold', 'heavy', 'black']] = 'bold',
    axis_fontsize: Union[int, float, Literal['xx-small', 'x-small', 'small',
                         'medium', 'large', 'x-large', 'xx-large']] = None,
    axis_fontweight: Union[int, Literal['light', 'normal', 'medium', 
                           'semibold', 'bold', 'heavy', 'black']] = 'bold',
) :
    """
    Generate an alluvial plot for NSBM hierarchy

    This plot may be useful to study the hierarchical relations in a Nested
    Model generated by `scnbsm.inference.nested_model`.    Note that the `level_end`
    
    Parameters
    ----------
    adata
        The annotated data matrix.
    level_start
        The deepest level in the hierarchy (i.e. the one with more clusters)
        Note that this parameter marks the leafs of the tree
    level_end
        The coarser level in hierarchy. Default value is `None`, if pruning has not
        been performed, it may be useful to exclude uninformative levels anyway    
        Note that this parameter marks the root of the tree
    key
        The key used to group cells. Default is `nsbm`
    gap
        The gap between groups in percentage
"""    
    level_key = "%s_level" % key
    levels = adata.obs.filter(like=f"{key}_level").columns
    if level_start < 0:
        level_start = 1
    if not level_end:
        level_end = len(levels)
    if level_end < level_start:
        # swap values if they are reversed
        (level_start, level_end )= (level_end, level_start)
    #reverse levels
#    levels = levels[(level_start - 1):level_end][::-1]
    levels = levels[level_start:level_end + 1][::-1]
    if len(levels) == 0:
        raise ValueError(
        """No levels to plot were found
        """
        )
    if gap < 0:
        gap = 0
        
    n_cells = adata.shape[0]
    
    e_pos = None # set this to none, later it will be the last of the previous iteration
    fig, ax = plt.subplots()
    gap = n_cells * gap
    for l in range(len(levels) - 1):
        s_level = levels[l]
        e_level = levels[l + 1]
    
        # count the cross counts
        ct = pd.crosstab(adata.obs.loc[:, s_level], adata.obs.loc[:, e_level])
    
        # these need to be fixed to prevent crossing of the veins
        # they kind of work right now
        
        _order = []  # this should be the order of vein ends
        _tree = {}   # this should keep track of starts and ends for each vein
        for i in ct.index:
            _tree[i] = []
            for c in ct.columns[ct.loc[i] > 0]:
                _order.append(c)
                _tree[i].append(c)
    
        # get the cumulative values for start and ends 
        cum_s = np.cumsum(np.sum(ct, axis=1))
        cum_e = np.cumsum(np.sum(ct.loc[:, _order], axis=0))
    
        # prepend a 0 to each, also use arrays in place of dataframe
        # just because I like them most
        
        _cum_s = np.array([0] + list(cum_s))
        _cum_e = np.array([0] + list(cum_e))
    
        # transform cumulatives in coordinates of the start/end block
        _s_pos = np.vstack([_cum_s[:-1], _cum_s[1:]]).T
        _e_pos = np.vstack([_cum_e[:-1], _cum_e[1:]]).T
    

        for x in range(len(_s_pos)):
            # add a gap between start blocks
            _s_pos[x] = _s_pos[x] + gap * x
        for x in range(len(_e_pos)):
            # add it to end blocks as well
            _e_pos[x] = _e_pos[x] + gap * x
        # now rescale everything to 1, that is the last values in positions        
        _s_pos = _s_pos / _s_pos[-1, 1]    
        _e_pos = _e_pos / _e_pos[-1, 1]    
    
        if type(e_pos) != type(None):
            # from the 2nd iterations on, just use the previous ends as new starts
            s_pos = e_pos
        else:
            # otherwise generate them from scratch. Use a dataframe as
            # ordering has changed
            s_pos = pd.DataFrame(_s_pos, index=cum_s.index)
        e_pos = pd.DataFrame(_e_pos, index=cum_e.index)

        # start generating plot. 
        sl = l
        el = l + 1 
        
        xr = np.linspace(sl, el)
    
        # now go into the tree
        for s in _tree.keys():
            # get the highest and lowest points for a block
            s_h, s_l = s_pos.loc[s]
            if l == 1:
                # annotate groups of the rootmost groups
                ax.text(l, (s_h + s_l) / 2, s, 
                        fontsize=legend_fontsize, 
                        fontweight=legend_fontweight)
            for e in _tree[s]:
                # for every ordered child block get the highest/lowest points
                e_h, e_l = e_pos.loc[e]
                # use the logistic curve to derive the boundaries of the wedge
                # I'm using a steepness factor of 20, maybe this can be 
                # specified in parameters?
                trace_h = (e_h - s_h) / (1 +np.exp(-20 * (xr - (sl + el)/2))) + s_h
                trace_l = (e_l - s_l) / (1 +np.exp(-20 * (xr - (sl + el)/2))) + s_l
                # Here colors are the matplotlib default ones, 
                # It would be a good idea to specify them using the very same
                # approach used by scanpy.
                if f'{s_level}_colors' in adata.uns:
                    # if colors have been used previously, use them
                    color = adata.uns[f'{s_level}_colors'][int(s)]
                else:
                    # TODO: change color cycler according to the number of groups
                    color = "C%s" % s
                # generate the polygon vertex list
                verts = [(sl, s_l), (sl, e_h),
                         *zip(xr, trace_l),
                         *zip(xr[::-1], trace_h[::-1]),
                        ]
                poly = Polygon(verts, facecolor=color)
                ax.add_patch(poly)
                
                # annotate the groups with the group names.
                ax.text(l + 1, (e_h + e_l) / 2, e, 
                        fontsize=legend_fontsize, 
                        fontweight=legend_fontweight)
        
        
    ax.set_xlim(0, l)
    ax.set_xticks(range(len(levels)))
    # strip level key
    levels = [x.replace("%s_level_" % key, '') for x in levels]
    ax.set_xticklabels(levels, fontsize=axis_fontsize, 
                       fontweight=axis_fontweight)
    ax.set_yticks([])
    ax.grid(visible=False)
    ax.set_xlabel(f"{key} level")
